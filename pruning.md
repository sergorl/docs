## MMR
***Merkle Mountain Range (MMR)*** - бинарное дерево, узлы которого есть хэши некоторых сущностей, а сами узлы хранятся в некотором массиве в порядке post-order. Так на рисунке ниже нумерация узлов соответствует их индексации в массиве, которая и отображает post-order.
![](https://github.com/sergorl/docs/blob/master/mmr.png)

Важно прояснить следующие понятия для **MMR-дерева**:
* Все родители являются пиками дерева (как минимум дерева их трёх элемнтов).
* Узлы, имеющие одного общего родителя являются братьями.
* Все узлы имеют высоту.
* Child-узлы имеют нулевую высоту.

## Pruning и PMMR
***Pruning*** – техника сокращения размерности бинарного дерева для упрощения проверки наличия некоторого элемента-узла в структуре дерева.

Есть несколько ситуаций, в которых применяется **pruning**:
* Полностью прошедший валидацию узел может избавиться от избыточных данных для освобождения памяти;
* Частично прошедший валидацию узел может быть не заинтересован в приёме или хранениии данных;
* Когда новый узел, присоединяется к сети, то временно он может вести себя как частично прошедший валидацию для ускорения работы. В дальнейшем подобный узел может пройти валидацию полностью.

**Pruning** возможно осуществлять только для **сhild-узлов**, высота которых равна нулю.

***Prunable Merkle Mountain Range (PMMR)*** - **MMR-дерево**, предварительно прошедшее **pruning**. Такое дерево существует для некоторого стартового **child-узла** из полного MMR-дерева и задаётся двумя массивами:
* массивом пиков и
* массивом узлов-братьев для соответсвущих пиков.
Данная структура **PMMR-дерева** в виде массива из пиков и узлов-братьев хранится в поле **MerkleProof** у каждого **Input**'a транзакции.

![](https://github.com/sergorl/docs/blob/master/pmmr.png)

Так для узла №4:
* пики = {6, 7, 15},
* а братья = {5, 3, 14}

## Merkle Proof
***Merkle Proof*** - процедура проверки наличия узла в **MMR-дереве**.

**Pruning** полезен для **Merkle Proof**, так как позволяет устранить избыточность узлов в **MMR-дереве**, то есть удалить узлы, которые не участвуют в процедуре, повысив эффективность проверки. 

Расмотрим алгоритм **Merkle Proof** в **PMMR-дереве**. Данный алгоритм проверки описан в в строчках [208-251](https://github.com/beam-mw/grin/blob/master/core/src/core/pmmr.rs) и является крайне НЕПОНЯТНЫМ, так как предполагет, что для каждого хэша внутри MerkleProof'а каждого входа транзакции хранятся известные для него узлы-братья и все пики. Сам алгоритм фактически состит их двух этапов:

1. Для проверяемого узла из массива братьев изымается его узел-брат и из хэшей этих узлов формируется новый хэш нового узла-родителя. Далее для нового узла процедура повторяется рекурсивно до тех пор пока не опустеет массив узлов братьев. При этом каждый раз форимруется новый MerkleProof, на ктором и запускается рекурсивно функция проверки.
2. 
